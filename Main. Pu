#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Ø¨ÙˆØª Ø¨Ù„ÙˆÙ… - Ù…Ù„Ù ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· Ù„Ù„ØªØ´ØºÙŠÙ„
================================
ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø¶Ø§ÙØ© ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø¹Ø¨Ø± Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
"""

import os
import sys
import asyncio
import random
import requests
import json
import time
from datetime import datetime
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError, FloodWaitError

# ================ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ© ================
BOT_TOKEN = "8546862642:AAGtrE_iJXglP4tyfYKRvLxK0jXKZm37YO0"  # âœ… ØªÙˆÙƒÙ†Ùƒ
API_ID = 38700083  # âœ… Ù„Ø§ ØªØºÙŠØ±Ù‡
API_HASH = "bbe7d9a92a90bb5fccadea082ac0c386"  # âœ… Ù„Ø§ ØªØºÙŠØ±Ù‡
YOUR_USER_ID = 7096534637  # âœ… Ù„Ø§ ØªØºÙŠØ±Ù‡

# ================ Ù…ØªØºÙŠØ±Ø§Øª ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© ================
# Ù‡Ø°Ø§ Ø§Ù„Ù…ØªØºÙŠØ± Ø±Ø§Ø­ ÙŠØªØºÙŠØ± Ù„Ù…Ø§ ØªØ±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©
REF_CODE = None  # Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ«Ù‡ Ø¹Ø¨Ø± Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©

# ================ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ================
BLUM_BOT = "BlumCryptoBot"
CHECK_INTERVAL = 8 * 60 * 60
TASK_DELAY_MIN = 10
TASK_DELAY_MAX = 30
USE_PROXY = True

PROXY_SOURCES = [
    "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/socks5.txt",
    "https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/socks5.txt"
]

def fetch_free_proxies():
    proxies = []
    for url in PROXY_SOURCES:
        try:
            r = requests.get(url, timeout=5)
            if r.status_code == 200:
                proxies.extend([p.strip() for p in r.text.split('\n') if p.strip() and ':' in p])
        except:
            pass
    return list(set(proxies))[:30]

def parse_proxy(p):
    try:
        if '://' in p: p = p.split('://')[-1]
        parts = p.split(':')
        if len(parts) == 2:
            return {'proxy_type': 'socks5', 'addr': parts[0], 'port': int(parts[1])}
    except:
        return None

class AccountManager:
    def __init__(self):
        self.accounts = {}
        self.proxies = fetch_free_proxies() if USE_PROXY else []
        self.pending = {}
        
    def get_proxy(self):
        return parse_proxy(random.choice(self.proxies)) if self.proxies else None
    
    async def load_saved(self):
        session_files = [f for f in os.listdir('.') if f.endswith('.session')]
        for f in session_files:
            try:
                phone = f.replace('.session', '')
                if phone and phone[0].isdigit():
                    phone = '+' + phone
                client = TelegramClient(f, API_ID, API_HASH, proxy=self.get_proxy())
                await client.connect()
                if await client.is_user_authorized():
                    self.accounts[phone] = {'client': client, 'phone': phone}
            except:
                pass

class ControlBot:
    def __init__(self):
        self.manager = AccountManager()
        self.bot = None
        self.ref_code = None  # Ù‡Ù†Ø§ ÙŠØªÙ… ØªØ®Ø²ÙŠÙ† ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©
        
    async def start(self):
        print("âœ… Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
        await self.manager.load_saved()
        self.bot = TelegramClient('bot', API_ID, API_HASH)
        await self.bot.start(bot_token=BOT_TOKEN)
        print("âœ… Ø¨ÙˆØª Ø§Ù„ØªØ­ÙƒÙ… Ø´ØºØ§Ù„ Ø§Ù„Ø¢Ù†!")
        
        @self.bot.on(events.NewMessage)
        async def handler(event):
            if event.sender_id != YOUR_USER_ID:
                await event.reply("â›” Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ")
                return
            
            text = event.text.strip()
            
            if text == '/start':
                await event.reply(
                    "ğŸ¤– **Ø¨ÙˆØª Ø¨Ù„ÙˆÙ…**\n\n"
                    "ğŸ“± **Ù„Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨:** Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ù‚Ù… (Ù…Ø«Ø§Ù„: +9647xxxxxxxx)\n"
                    "ğŸ”— **Ù„Ø¥Ø¶Ø§ÙØ© ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©:** Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ ÙÙ‚Ø· (Ù…Ø«Ø§Ù„: AbCdEfGh)\n"
                    "ğŸ“‹ **Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª:** /accounts\n"
                    "ğŸŒ¾ **Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ†:** /farm\n"
                    "ğŸ”„ **ØªÙØ¹ÙŠÙ„ Ø¥Ø­Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨:** /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨\n"
                    "ğŸ‘€ **Ø¹Ø±Ø¶ ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ:** /myref"
                )
            
            elif text == '/accounts':
                if not self.manager.accounts:
                    await event.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª")
                    return
                msg = "ğŸ“‹ **Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª:**\n"
                for i, phone in enumerate(self.manager.accounts.keys(), 1):
                    msg += f"{i}. `{phone}`\n"
                await event.reply(msg)
            
            elif text == '/farm':
                if not self.manager.accounts:
                    await event.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª")
                    return
                await event.reply("ğŸŒ¾ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ†...")
                for phone, acc in self.manager.accounts.items():
                    try:
                        await acc['client'].send_message(BLUM_BOT, '/start')
                        await asyncio.sleep(random.randint(TASK_DELAY_MIN, TASK_DELAY_MAX))
                    except:
                        pass
                await event.reply("âœ… Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ØªØ¹Ø¯ÙŠÙ†")
            
            elif text == '/myref':
                if self.ref_code:
                    await event.reply(f"ğŸ”— ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ: `{self.ref_code}`")
                else:
                    await event.reply("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø© Ø­Ø§Ù„ÙŠØ§Ù‹. Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù„Ø¥Ø¶Ø§ÙØªÙ‡")
            
            elif text.startswith('/ref'):
                parts = text.split()
                if len(parts) != 2:
                    await event.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨")
                    return
                try:
                    idx = int(parts[1]) - 1
                    phone = list(self.manager.accounts.keys())[idx]
                    acc = self.manager.accounts[phone]
                    
                    if self.ref_code:
                        await acc['client'].send_message(BLUM_BOT, f'/start ref_{self.ref_code}')
                        await event.reply(f"âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø¨ÙƒÙˆØ¯ `{self.ref_code}` Ù„Ù„Ø­Ø³Ø§Ø¨ {phone}")
                    else:
                        await event.reply("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø©. Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹")
                except Exception as e:
                    await event.reply(f"âŒ Ø®Ø·Ø£: {str(e)}")
            
            elif text.startswith('+'):
                # Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯
                phone = text
                await event.reply(f"ğŸ“± Ø¬Ø§Ø±ÙŠ Ø¥Ø¶Ø§ÙØ© {phone}...")
                try:
                    if not os.path.exists('accounts'):
                        os.makedirs('accounts')
                    
                    client = TelegramClient(f"accounts/{phone.replace('+', '')}", API_ID, API_HASH, proxy=self.manager.get_proxy())
                    await client.connect()
                    await client.send_code_request(phone)
                    self.manager.pending[phone] = client
                    await event.reply("ğŸ“² Ø£Ø±Ø³Ù„ Ø±Ù…Ø² Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¢Ù†")
                except Exception as e:
                    await event.reply(f"âŒ Ø®Ø·Ø£: {str(e)}")
            
            elif text.replace('_', '').isalnum() and len(text) > 5 and not text.startswith('/'):
                # Ù‡Ø°Ø§ Ø§Ù„Ù†Øµ ÙŠØ¹ØªØ¨Ø± ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø© (Ø­Ø±ÙˆÙ ÙˆØ£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·)
                self.ref_code = text.strip()
                await event.reply(f"ğŸ”— ØªÙ… Ø­ÙØ¸ ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©: `{self.ref_code}`\nØ§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„ØªÙØ¹ÙŠÙ„Ù‡")
            
            else:
                # Ø§Ø­ØªÙ…Ø§Ù„ ÙŠÙƒÙˆÙ† Ø±Ù…Ø² ØªØ­Ù‚Ù‚
                for phone, client in list(self.manager.pending.items()):
                    try:
                        await client.sign_in(phone, text)
                        if await client.is_user_authorized():
                            self.manager.accounts[phone] = {'client': client, 'phone': phone}
                            del self.manager.pending[phone]
                            msg = f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© {phone}"
                            if self.ref_code:
                                msg += f"\n\nğŸ”— ÙŠÙ…ÙƒÙ†Ùƒ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø§Ù„Ø¢Ù† Ø¨Ù€ /ref {len(self.manager.accounts)}"
                            await event.reply(msg)
                        return
                    except SessionPasswordNeededError:
                        self.manager.pending[phone + '_2fa'] = client
                        del self.manager.pending[phone]
                        await event.reply("ğŸ”‘ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙØ¹Ù„ Ø¹Ù„ÙŠÙ‡ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø®Ø·ÙˆØªÙŠÙ†\nØ£Ø±Ø³Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±")
                        return
                    except Exception as e:
                        await event.reply(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚: {str(e)}")
                        return
                
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠØ©
                for key, client in list(self.manager.pending.items()):
                    if key.endswith('_2fa'):
                        try:
                            await client.sign_in(password=text)
                            phone = key.replace('_2fa', '')
                            self.manager.accounts[phone] = {'client': client, 'phone': phone}
                            del self.manager.pending[key]
                            msg = f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© {phone}"
                            if self.ref_code:
                                msg += f"\n\nğŸ”— ÙŠÙ…ÙƒÙ†Ùƒ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø§Ù„Ø¢Ù† Ø¨Ù€ /ref {len(self.manager.accounts)}"
                            await event.reply(msg)
                            return
                        except Exception as e:
                            await event.reply(f"âŒ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©: {str(e)}")
                            return
                
                await event.reply("âŒ Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
        
        await self.bot.run_until_disconnected()

async def main():
    bot = ControlBot()
    await bot.start()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª")
    except Exception as e:
        print(f"\nâŒ Ø®Ø·Ø£: {e}")
