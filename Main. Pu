#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Ø¨ÙˆØª Ø¨Ù„ÙˆÙ… - Ù…Ù„Ù ÙˆØ§Ø­Ø¯ Ø´Ø§Ù…Ù„
================================
Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡: Ø§Ù„ÙƒÙˆØ¯ + Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª
"""

# ================ ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ================
import subprocess
import sys
import os

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
REQUIRED_PACKAGES = ['telethon', 'requests', 'colorama', 'cryptg', 'pyaes', 'rsa']

# Ø¯Ø§Ù„Ø© Ù„ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª
def install_packages():
    for package in REQUIRED_PACKAGES:
        try:
            __import__(package)
            print(f"âœ… {package} Ù…Ø«Ø¨Øª Ù…Ø³Ø¨Ù‚Ø§Ù‹")
        except ImportError:
            print(f"ğŸ“¦ Ø¬Ø§Ø±ÙŠ ØªØ«Ø¨ÙŠØª {package}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
            print(f"âœ… ØªÙ… ØªØ«Ø¨ÙŠØª {package}")

# ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø¨Ø¯Ø¡
print("ğŸ”§ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©...")
install_packages()
print("âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø¬Ø§Ù‡Ø²Ø©\n")

# ================ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª ================
import asyncio
import random
import requests
import json
import time
from datetime import datetime
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError, FloodWaitError
import colorama
from colorama import Fore, Style
colorama.init(autoreset=True)

# ================ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ© ================
BOT_TOKEN = "8546862642:AAGtrE_iJXglP4tyfYKRvLxK0jXKZm37YO0"
API_ID = 38700083
API_HASH = "bbe7d9a92a90bb5fccadea082ac0c386"
YOUR_USER_ID = 7096534637

# ================ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ================
BLUM_BOT = "BlumCryptoBot"
CHECK_INTERVAL = 8 * 60 * 60
TASK_DELAY_MIN = 10
TASK_DELAY_MAX = 30
USE_PROXY = True

PROXY_SOURCES = [
    "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/socks5.txt",
    "https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/socks5.txt"
]

def fetch_free_proxies():
    proxies = []
    for url in PROXY_SOURCES:
        try:
            r = requests.get(url, timeout=5)
            if r.status_code == 200:
                lines = r.text.strip().split('\n')
                for line in lines:
                    line = line.strip()
                    if line and ':' in line:
                        proxies.append(line)
        except:
            pass
    return list(set(proxies))[:30]

def parse_proxy(p):
    try:
        if '://' in p:
            p = p.split('://')[-1]
        parts = p.split(':')
        if len(parts) == 2:
            return {
                'proxy_type': 'socks5',
                'addr': parts[0],
                'port': int(parts[1])
            }
    except:
        return None

class AccountManager:
    def __init__(self):
        self.accounts = {}
        self.proxies = fetch_free_proxies() if USE_PROXY else []
        self.pending = {}
        
    def get_proxy(self):
        if not self.proxies:
            return None
        return parse_proxy(random.choice(self.proxies))
    
    async def load_saved(self):
        files = os.listdir('.')
        session_files = [f for f in files if f.endswith('.session')]
        for f in session_files:
            try:
                phone = f.replace('.session', '')
                if phone and phone[0].isdigit():
                    phone = '+' + phone
                client = TelegramClient(f, API_ID, API_HASH, proxy=self.get_proxy())
                await client.connect()
                if await client.is_user_authorized():
                    self.accounts[phone] = {
                        'client': client,
                        'phone': phone
                    }
            except:
                pass

class ControlBot:
    def __init__(self):
        self.manager = AccountManager()
        self.bot = None
        self.ref_code = None
        
    async def start(self):
        print(f"{Fore.CYAN}âœ… Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...{Style.RESET_ALL}")
        await self.manager.load_saved()
        print(f"{Fore.GREEN}âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ {len(self.manager.accounts)} Ø­Ø³Ø§Ø¨{Style.RESET_ALL}")
        
        self.bot = TelegramClient('bot_session', API_ID, API_HASH)
        await self.bot.start(bot_token=BOT_TOKEN)
        print(f"{Fore.GREEN}âœ… Ø¨ÙˆØª Ø§Ù„ØªØ­ÙƒÙ… Ø´ØºØ§Ù„ Ø§Ù„Ø¢Ù†!{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}ğŸ“± Ø§ÙØªØ­ ØªÙ„ØºØ±Ø§Ù… ÙˆØ§Ø¨Ø­Ø« Ø¹Ù† Ø¨ÙˆØªÙƒ{Style.RESET_ALL}")
        
        @self.bot.on(events.NewMessage)
        async def handler(event):
            if event.sender_id != YOUR_USER_ID:
                await event.reply("â›” Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ Ù„ØµØ§Ø­Ø¨Ù‡ ÙÙ‚Ø·")
                return
            
            text = event.message.text.strip()
            
            if text == '/start':
                await event.reply(
                    "ğŸ¤– **Ø¨ÙˆØª Ø¨Ù„ÙˆÙ… - Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª**\n\n"
                    "ğŸ“± **Ù„Ø¥Ø¶Ø§ÙØ© Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯:**\n"
                    "Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù…Ø¹ Ù…ÙØªØ§Ø­ Ø§Ù„Ø¯ÙˆÙ„Ø©\n"
                    "Ù…Ø«Ø§Ù„: `+9647xxxxxxxx`\n\n"
                    "ğŸ”— **Ù„Ø¥Ø¶Ø§ÙØ© ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©:**\n"
                    "Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ ÙÙ‚Ø· (Ù…Ù† Ø±Ø§Ø¨Ø· Blum)\n"
                    "Ù…Ø«Ø§Ù„: `AbCdEfGh`\n\n"
                    "ğŸ“‹ **Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª:** /accounts\n"
                    "ğŸŒ¾ **Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ†:** /farm\n"
                    "ğŸ”„ **ØªÙØ¹ÙŠÙ„ Ø¥Ø­Ø§Ù„Ø©:** /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨\n"
                    "ğŸ‘€ **Ø¹Ø±Ø¶ ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©:** /myref"
                )
            
            elif text == '/accounts':
                if not self.manager.accounts:
                    await event.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª Ù…Ø¶Ø§ÙØ©")
                    return
                msg = "ğŸ“‹ **Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©:**\n\n"
                for i, phone in enumerate(self.manager.accounts.keys(), 1):
                    msg += f"{i}. `{phone}`\n"
                await event.reply(msg)
            
            elif text == '/farm':
                if not self.manager.accounts:
                    await event.reply("âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨Ø§Øª")
                    return
                await event.reply("ğŸŒ¾ **Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ† Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª...**")
                for phone, acc in self.manager.accounts.items():
                    try:
                        await acc['client'].send_message(BLUM_BOT, '/start')
                        await asyncio.sleep(random.randint(TASK_DELAY_MIN, TASK_DELAY_MAX))
                    except Exception as e:
                        print(f"Ø®Ø·Ø£ Ù…Ø¹ {phone}: {e}")
                await event.reply("âœ… **Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ØªØ¹Ø¯ÙŠÙ†**")
            
            elif text == '/myref':
                if self.ref_code:
                    await event.reply(f"ğŸ”— ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ: `{self.ref_code}`")
                else:
                    await event.reply("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø©. Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù„Ø¥Ø¶Ø§ÙØªÙ‡")
            
            elif text.startswith('/ref'):
                parts = text.split()
                if len(parts) != 2:
                    await event.reply("âŒ Ø§Ø³ØªØ®Ø¯Ù…: /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨")
                    return
                try:
                    idx = int(parts[1]) - 1
                    phones = list(self.manager.accounts.keys())
                    if idx < 0 or idx >= len(phones):
                        await event.reply("âŒ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­")
                        return
                    phone = phones[idx]
                    acc = self.manager.accounts[phone]
                    
                    if self.ref_code:
                        await acc['client'].send_message(BLUM_BOT, f'/start ref_{self.ref_code}')
                        await event.reply(f"âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø© Ø¨ÙƒÙˆØ¯ `{self.ref_code}` Ù„Ù„Ø­Ø³Ø§Ø¨ {phone}")
                    else:
                        await event.reply("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ø¥Ø­Ø§Ù„Ø©. Ø£Ø±Ø³Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹")
                except Exception as e:
                    await event.reply(f"âŒ Ø®Ø·Ø£: {str(e)}")
            
            elif text.startswith('+'):
                phone = text
                await event.reply(f"ğŸ“± Ø¬Ø§Ø±ÙŠ Ø¥Ø¶Ø§ÙØ© {phone}...")
                try:
                    if not os.path.exists('accounts'):
                        os.makedirs('accounts')
                    
                    session_file = f"accounts/{phone.replace('+', '')}"
                    client = TelegramClient(session_file, API_ID, API_HASH, proxy=self.manager.get_proxy())
                    await client.connect()
                    await client.send_code_request(phone)
                    self.manager.pending[phone] = client
                    await event.reply("ğŸ“² ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ù…Ø². Ø£Ø±Ø³Ù„ Ø±Ù…Ø² Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¢Ù†")
                except Exception as e:
                    await event.reply(f"âŒ Ø®Ø·Ø£: {str(e)}")
            
            elif len(text) > 3 and not text.startswith('/'):
                found = False
                for phone, client in list(self.manager.pending.items()):
                    try:
                        await client.sign_in(phone, text)
                        if await client.is_user_authorized():
                            self.manager.accounts[phone] = {'client': client, 'phone': phone}
                            del self.manager.pending[phone]
                            msg = f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© {phone} Ø¨Ù†Ø¬Ø§Ø­"
                            if self.ref_code:
                                msg += f"\n\nğŸ”— Ø§Ø³ØªØ®Ø¯Ù… /ref {len(self.manager.accounts)} Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©"
                            await event.reply(msg)
                            found = True
                            break
                    except SessionPasswordNeededError:
                        self.manager.pending[phone + '_2fa'] = client
                        del self.manager.pending[phone]
                        await event.reply("ğŸ”‘ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙØ¹Ù„ Ø¹Ù„ÙŠÙ‡ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ø®Ø·ÙˆØªÙŠÙ†\nØ£Ø±Ø³Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±")
                        found = True
                        break
                    except Exception as e:
                        await event.reply(f"âŒ Ø®Ø·Ø£: {str(e)}")
                        found = True
                        break
                
                if not found:
                    for key, client in list(self.manager.pending.items()):
                        if key.endswith('_2fa'):
                            try:
                                await client.sign_in(password=text)
                                phone = key.replace('_2fa', '')
                                self.manager.accounts[phone] = {'client': client, 'phone': phone}
                                del self.manager.pending[key]
                                msg = f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© {phone} Ø¨Ù†Ø¬Ø§Ø­"
                                if self.ref_code:
                                    msg += f"\n\nğŸ”— Ø§Ø³ØªØ®Ø¯Ù… /ref {len(self.manager.accounts)} Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©"
                                await event.reply(msg)
                                found = True
                                break
                            except Exception as e:
                                await event.reply(f"âŒ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©: {str(e)}")
                                found = True
                                break
                
                if not found:
                    self.ref_code = text
                    await event.reply(f"ğŸ”— ØªÙ… Ø­ÙØ¸ ÙƒÙˆØ¯ Ø§Ù„Ø¥Ø­Ø§Ù„Ø©: `{self.ref_code}`\nØ§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù… /ref Ø±Ù‚Ù…_Ø§Ù„Ø­Ø³Ø§Ø¨ Ù„ØªÙØ¹ÙŠÙ„Ù‡")
            
            else:
                await event.reply("âŒ Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ. Ø£Ø±Ø³Ù„ /start Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©")
        
        await self.bot.run_until_disconnected()

async def main():
    bot = ControlBot()
    await bot.start()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}ğŸ‘‹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª{Style.RESET_ALL}")
    except Exception as e:
        print(f"\n{Fore.RED}âŒ Ø®Ø·Ø£: {e}{Style.RESET_ALL}")
